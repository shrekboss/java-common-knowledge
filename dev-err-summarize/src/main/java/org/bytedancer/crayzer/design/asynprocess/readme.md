## 异步处理好用，但非常容易用错
区别于同步处理，异步处理无需同步等待流程处理完毕，因此适用场景主要包括：
- 服务于主流程的分支流程。分支流程，时效性不那么强，可以进行异步处理。
- 用户不需要实时看到结果的流程。

异步处理因为可以有 MQ 中间件的介入用于任务的缓冲的分发，所以相比于同步处理，在应对流量洪峰、实
现模块解耦和消息广播方面有功能优势。

不过，异步处理虽然好用，但在实现的时候却有三个最容易犯的错，分别是**异步处理流程的可靠性问题**、
**消息发送模式的区分问题**，以及**大量死信消息堵塞队列的问题**。

### 异步处理需要消息补偿闭环：compensation
对于异步处理流程，必须考虑补偿或者说建立主备双活流程。

MQ 消费程序，处理逻辑务必考虑去重（支持幂等），原因有几个：
1. MQ 消息可能会因为中间件本身配置错误、稳定性等原因出现重复。
2. **自动补偿重复**，可能同一条消息可能既走 MQ 也走补偿，肯定会出现重复，而且考虑到高内聚，补偿 Job 
本身不会做去重处理。
3. **人工补偿重复**。出现消息堆积时，异步处理流程必然会延迟。如果提供了通过后台进行补偿的功能，那么在
处理遇到延迟的时候，很可能会先进行人工补偿，过了一段时间后处理程序又收到消息了，重复处理。

此外值得一说的是，Demo 中的补偿逻辑比较简单，生产级的代码应该在以下几个方面进行加强：
1. 考虑配置补偿的频次、每次处理数量，以及补偿线程池大小等参数为合适的值，以满足补偿的吞吐量。
2. 考虑备线补偿数据进行适当延迟。比如，对注册时间在 30 秒之前的用户再进行补偿，以方便和主线 MQ 
实时流程错开，避免冲突。
3. 诸如当前补偿到哪个用户的 offset 数据，需要落地数据库。
4. 补偿 Job 本身需要高可用，可以使用类似 XXLJob 或 ElasticJob 等任务系统。

针对消息的补偿闭环处理的**最高标准**是，能够达到补偿全量数据的吞吐量。也就是说，如果补偿备线足够
完善，即使直接把 MQ 停机，虽然会略微影响处理的及时性，但至少确保流程都能正常执行。

### 注意消息模式是广播还是工作队列：fanoutvswork
**消息广播**，同一条消息，不同消费者都能分别消费。
**队列模式**，不同消费者共享消费同一个队列的数据，相同消息只能被某一个消费者消费一次。

> 比如，同一个用户的注册消息，会员服务需要监听以发送欢迎短信，营销服务同样需要监听以发送新用户小礼
> 物。但是，会员服务、营销服务都可能有多个实例，期望的是同一个用户的消息，可以同时广播给不同的服务
> （广播模式），但对于同一个服务的不同实例（比如会员服务 1 和会员服务 2），不管哪个实例来处理，处理
> 一次即可（工作队列模式）。

**对于类似 RocketMQ 这样的 MQ 来说**，实现类似功能比较简单直白：
- 如果消费者属于一个组，那么消息只会由同一个组的一个消费者来消费；
- 如果消费者属于不同组，那么每个组都能消费一遍消息。
**而对于 RabbitMQ 来说**，消息路由的模式采用的是**队列 + 交换器**，队列是消息的载体，交换器决定
了消息路由到队列的方式，配置比较复杂，容易出错。

对于异步流程来说，消息路由模式一旦配置出错，轻则可能导致消息的重复处理，重则可能导致重要的服务无
法接收到消息，最终造成业务逻辑错误。
**参考：WorkQueueWrong/WorkQueueRight && FanoutQueueRight/FanoutQueueWrong 两个配置错误**

### 别让死信堵塞了消息队列：deadletter
对于突发流量引起的消息队列堆积，问题并不大，适当调整消费者的消费能力应该就可以解决。**但在很多时候，
消息队列的堆积堵塞，是因为有大量始终无法处理的消息。**

### （补充）使用RMQ的DLX实现延迟重试：rabbitmqdlx
rabbitmq 管理台：http://localhost:15672/ admin/admin

**解决死信无限重复进入队列最简单的方式是**，在程序处理出错的时候，直接抛出 
AmqpRejectAndDontRequeueException 异常，避免消息重新进入队列
`throw new AmqpRejectAndDontRequeueException("error");`

如果能够先进行几次重试，解决因为网络问题导致的偶发消息处理失败，如果还是不行的话，再把消息投递到
专门的一个死信队列。对于来自死信队列的数据，可能只是记录日志发送报警，即使出现异常也不会再重复投
递。
**Spring AMQP 提供了非常方便的解决方案：**
- 首先，定义死信交换器和死信队列。其实，这些都是普通的交换器和队列，只不过被专门用于处理死信消息。
- 然后，通过 RetryInterceptorBuilder 构建一个 RetryOperationsInterceptor，用于处理失败时候的重试。
这里的策略是，最多尝试 5 次（重试 4 次）；并且采取指数退避重试，首次重试延迟 1 秒，第二次 2 秒，
以此类推，最大延迟是 10 秒；如果第 4 次重试还是失败，则使用 RepublishMessageRecoverer 把消息重新投
入一个“死信交换器”中。
- 最后，定义死信队列的处理程序。这个案例中，只是简单记录日志。