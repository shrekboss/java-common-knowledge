## HTTP调用：你考虑到超时、重试、并发了吗？
### 配置连接超时和读取超时参数的学问：clientreadtimeout
- **第一个误区**：认为出现了读取超时，服务端的执行就会中断。
- **第二个误区**：认为读取超时只是 Socket 网络层面的概念，是数据传输的最长耗时，故将其配置得非常短，
比如 100 毫秒。
- **第三个误区**：认为超时时间越长任务接口成功率就越高，将读取超时参数配置得太长。
    - 对定时任务或异步任务来说，读取超时配置可以适当的长些问题不大。
    - 进行 HTTP 请求一般是需要获得结果的，属于同步调用。如果超时时间很长，在等待服务端返回数据的
    同时，客户端线程（通常是 Tomcat 线程）也在等待，当下游服务出现大量超时的时候，程序可能也会受
    到拖累创建大量线程，最终崩溃。

**“写入超时”的概念**
- 写入操作只是将数据写入 TCP 的发送缓冲区，已经发送到网络的数据依然需要暂存在发送缓冲区中，只有
收到对方的 ack 后，操作系统内核才从缓冲区中清除这一部分数据，为后续发送数据腾出空间。
- 如果接收端从 socket 读取数据的速度太慢，可能会导致**发送端发送缓冲区满，导致写入操作阻塞，产生写
入超时**。但是，因为有**滑动窗口的控制**，通常不太容易发生发送缓冲区满导致写入超时的情况。相反，
读取超时包含了服务端处理数据执行业务逻辑的时间，所以读取超时是比较容易发生的。

### Feign和Ribbon配合使用，你知道怎么配置超时吗？：feignandribbontimeout
### 你是否知道Ribbon会自动重试请求呢：ribbonretry
### 并发限制了爬虫的抓取能力：routelimit
### （补充）Feign方法级别设置超时的例子：feignpermethodtimeout
- **Ribbon 的 AutoRetriesNextServer 重试机制**
- Nginx 也有类似的重试功能 proxy_next_upstream
> proxy_next_upstream error timeout http_500;
- proxy_next_upstream，用于指定在什么情况下 Nginx 会将请求转移到其他服务器上。其**默认值是 
proxy_next_upstream error timeout**，即发生网络错误以及超时，才会重试其他服务器。也就是说，默认
情况下，服务返回 500 状态码是不会重试的。 
- **需要注意的是**，proxy_next_upstream 配置中有一个选项 **non_idempotent**，一定要小心开启。通
常情况下，如果请求使用非等幂方法（POST、PATCH），请求失败后不会再到其他服务器进行重试。但是，
**加上 non_idempotent 这个选项后，即使是非幂等请求类型（例如 POST 请求），发生错误后也会重试**。